<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å•è¯å­¦ä¹  - æ™ºèƒ½ç¿»è¯‘åŠ©æ‰‹</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='vocabulary.css') }}">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700&display=swap" rel="stylesheet">
    <!-- ä¸»é¢˜é¢„åŠ è½½è„šæœ¬ - é¿å…ä¸»é¢˜é—ªçƒ -->
    <script>
        (function() {
            // åœ¨DOMæ¸²æŸ“å‰åº”ç”¨ä¿å­˜çš„ä¸»é¢˜
            const savedTheme = localStorage.getItem('theme') || 'harajuku';
            const root = document.documentElement;
            
            // å…ˆæ¸…é™¤æ‰€æœ‰ä¸»é¢˜ç±»
            root.classList.remove('pixel-theme', 'cyberpunk-theme');
            
            // åº”ç”¨ä¿å­˜çš„ä¸»é¢˜
            if (savedTheme === 'pixel') {
                root.classList.add('pixel-theme');
            } else if (savedTheme === 'cyberpunk') {
                root.classList.add('cyberpunk-theme');
            }
        })();
    </script>
</head>
<body>
    <!-- ä¸»é¢˜åˆ‡æ¢æŒ‰é’® -->
    <button id="themeToggle" class="theme-toggle">
        <span class="icon">ğŸ¨</span>
        <span class="text">ä¸»é¢˜</span>
    </button>
    
    <!-- ä¸»é¢˜é€‰æ‹©ä¸‹æ‹‰èœå• -->
    <div id="themeMenu" class="theme-menu">
        <div class="theme-option" data-theme="harajuku">
            <span class="theme-option-icon">ğŸŒ¸</span>
            <span class="theme-option-name">åŸå®¿é£</span>
        </div>
        <div class="theme-option" data-theme="pixel">
            <span class="theme-option-icon">ğŸ®</span>
            <span class="theme-option-name">åƒç´ é£</span>
        </div>
        <div class="theme-option" data-theme="cyberpunk">
            <span class="theme-option-icon">ğŸŒƒ</span>
            <span class="theme-option-name">æœªæ¥æœ‹å…‹</span>
        </div>
    </div>

    <div class="container">
        <header>
            <div class="title-container">
                <h1 class="title">å•è¯å­¦ä¹ </h1>
                <p class="subtitle">è‹±è¯­è¯æ±‡åº“</p>
            </div>
            <nav class="nav-links">
                <a href="/" class="nav-link">è¿”å›ç¿»è¯‘</a>
            </nav>
        </header>

        <div class="search-section">
            <input type="text" id="searchInput" class="search-input" placeholder="æœç´¢å•è¯æˆ–ä¸­æ–‡å«ä¹‰...">
            <div class="search-options">
                <label class="case-sensitive-label">
                    <input type="checkbox" id="caseSensitiveCheckbox">
                    <span class="checkbox-text">åŒºåˆ†å¤§å°å†™</span>
                </label>
            </div>
            <button id="searchBtn" class="action-btn">æœç´¢</button>
            <button id="randomBtn" class="action-btn">éšæœº50ä¸ª</button>
        </div>

        <div class="vocabulary-container">
            <div id="wordList" class="word-list">
                <!-- å•è¯å¡ç‰‡å°†é€šè¿‡JavaScriptåŠ¨æ€æ·»åŠ  -->
            </div>
            
            <!-- æ·»åŠ æ–°å•è¯çš„å¼¹çª— -->
            <div id="addWordModal" class="add-word-modal">
                <div class="add-word-content">
                    <span class="close-modal">&times;</span>
                    <h3>æ·»åŠ æ–°å•è¯</h3>
                    <p id="modalMessage">æœªæ‰¾åˆ°å•è¯"<span id="searchedWord"></span>"ï¼Œæ˜¯å¦æ·»åŠ åˆ°å•è¯åº“ï¼Ÿ</p>
                    <div class="form-group">
                        <label for="wordInput">å•è¯:</label>
                        <input type="text" id="wordInput" class="modal-input" autocomplete="off">
                    </div>
                    <div class="form-group">
                        <label for="translationInput">ç¿»è¯‘ (è¯æ€§.å«ä¹‰):</label>
                        <input type="text" id="translationInput" class="modal-input" placeholder="ä¾‹å¦‚: n.è‹¹æœ æˆ– v.è·‘" autocomplete="off">
                        <small class="input-tip">æç¤º: è¾“å…¥è¯æ€§ååŠ ç‚¹ï¼Œå¦‚"n."è¡¨ç¤ºåè¯ï¼Œ"v."è¡¨ç¤ºåŠ¨è¯</small>
                    </div>
                    <div class="modal-buttons">
                        <button id="addWordBtn" class="action-btn">æ·»åŠ å•è¯</button>
                        <button id="cancelAddBtn" class="cancel-btn">å–æ¶ˆ</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            let allWords = []; // å­˜å‚¨æ‰€æœ‰å•è¯
            let shownWords = []; // å­˜å‚¨å·²ç»å±•ç¤ºè¿‡çš„å•è¯çš„ID
            let currentDisplayedWords = []; // å½“å‰æ˜¾ç¤ºçš„50ä¸ªå•è¯
            let isThemeMenuOpen = false;
            
            // ä¸»é¢˜åˆ‡æ¢åŠŸèƒ½
            const themeToggle = document.getElementById('themeToggle');
            const themeMenu = document.getElementById('themeMenu');
            const themeOptions = document.querySelectorAll('.theme-option');
            
            // åº”ç”¨ä¿å­˜çš„ä¸»é¢˜
            function applyTheme() {
                const savedTheme = localStorage.getItem('theme') || 'harajuku';
                const root = document.documentElement;
                
                // ç§»é™¤æ‰€æœ‰ä¸»é¢˜ç±»
                root.classList.remove('pixel-theme', 'cyberpunk-theme');
                
                // åº”ç”¨ä¿å­˜çš„ä¸»é¢˜
                if (savedTheme === 'pixel') {
                    root.classList.add('pixel-theme');
                } else if (savedTheme === 'cyberpunk') {
                    root.classList.add('cyberpunk-theme');
                }
                
                // æ›´æ–°ä¸»é¢˜é€‰é¡¹çš„é€‰ä¸­çŠ¶æ€
                themeOptions.forEach(option => {
                    if (option.dataset.theme === savedTheme) {
                        option.classList.add('active');
                    } else {
                        option.classList.remove('active');
                    }
                });
            }
            
            // åº”ç”¨ä¸»é¢˜ï¼ˆåœ¨DOMåŠ è½½å®Œæˆåç«‹å³æ‰§è¡Œï¼‰
            applyTheme();
            
            // ä¸»é¢˜èœå•æ˜¾ç¤º/éšè—åŠŸèƒ½
            themeToggle.addEventListener('click', function(e) {
                e.stopPropagation();
                
                if (isThemeMenuOpen) {
                    themeMenu.classList.remove('active');
                } else {
                    themeMenu.classList.add('active');
                }
                
                isThemeMenuOpen = !isThemeMenuOpen;
            });
            
            // ç‚¹å‡»æ–‡æ¡£å…¶ä»–åœ°æ–¹å…³é—­ä¸»é¢˜èœå•
            document.addEventListener('click', function() {
                if (isThemeMenuOpen) {
                    themeMenu.classList.remove('active');
                    isThemeMenuOpen = false;
                }
            });
            
            // é˜»æ­¢èœå•å†…çš„ç‚¹å‡»äº‹ä»¶å†’æ³¡åˆ°æ–‡æ¡£
            themeMenu.addEventListener('click', function(e) {
                e.stopPropagation();
            });
            
            // ä¸»é¢˜é€‰é¡¹ç‚¹å‡»äº‹ä»¶
            themeOptions.forEach(option => {
                option.addEventListener('click', function() {
                    const theme = this.dataset.theme;
                    const root = document.documentElement;
                    
                    // ç§»é™¤æ‰€æœ‰ä¸»é¢˜ç±»
                    root.classList.remove('pixel-theme', 'cyberpunk-theme');
                    
                    // åº”ç”¨é€‰æ‹©çš„ä¸»é¢˜
                    if (theme === 'pixel') {
                        root.classList.add('pixel-theme');
                    } else if (theme === 'cyberpunk') {
                        root.classList.add('cyberpunk-theme');
                    }
                    
                    // æ›´æ–°é€‰ä¸­çŠ¶æ€
                    themeOptions.forEach(opt => opt.classList.remove('active'));
                    this.classList.add('active');
                    
                    // ä¿å­˜ä¸»é¢˜è®¾ç½®
                    localStorage.setItem('theme', theme);
                    
                    // å…³é—­ä¸»é¢˜èœå•
                    themeMenu.classList.remove('active');
                    isThemeMenuOpen = false;
                });
            });
            
            // é¢„å…ˆæ¿€æ´»éŸ³é¢‘ä¸Šä¸‹æ–‡ï¼Œè§£å†³ä¸€äº›æµè§ˆå™¨è¦æ±‚ç”¨æˆ·äº¤äº’æ‰èƒ½æ’­æ”¾éŸ³é¢‘çš„é™åˆ¶
            function initAudio() {
                // åˆ›å»ºä¸€ä¸ªé™éŸ³çš„éŸ³é¢‘ä¸Šä¸‹æ–‡
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // åˆ›å»ºä¸€ä¸ªé™éŸ³çš„éŸ³é¢‘å…ƒç´ 
                const silentAudio = new Audio();
                silentAudio.volume = 0.01; // å‡ ä¹é™éŸ³
                
                // å½“ç”¨æˆ·é¦–æ¬¡ä¸é¡µé¢äº¤äº’æ—¶ï¼Œæ’­æ”¾é™éŸ³éŸ³é¢‘å¹¶åŠ è½½è¯­éŸ³åˆæˆ
                document.body.addEventListener('click', function audioInitializer() {
                    // æ’­æ”¾é™éŸ³éŸ³é¢‘
                    silentAudio.play().catch(e => console.log('é™éŸ³éŸ³é¢‘åˆå§‹åŒ–å¤±è´¥ï¼Œè¿™æ˜¯æ­£å¸¸çš„'));
                    
                    // æ¿€æ´»è¯­éŸ³åˆæˆ
                    if ('speechSynthesis' in window) {
                        window.speechSynthesis.speak(new SpeechSynthesisUtterance(''));
                    }
                    
                    // ç§»é™¤äº‹ä»¶ç›‘å¬å™¨ï¼Œåªéœ€æ‰§è¡Œä¸€æ¬¡
                    document.body.removeEventListener('click', audioInitializer);
                    
                    console.log('éŸ³é¢‘ä¸Šä¸‹æ–‡å·²åˆå§‹åŒ–');
                }, { once: true });
            }
            
            // åˆå§‹åŒ–éŸ³é¢‘ç¯å¢ƒ
            initAudio();
            
            // ä»localStorageè·å–å·²ä¿å­˜çš„æ•°æ®
            function loadFromLocalStorage() {
                try {
                    // è·å–å·²æ˜¾ç¤ºçš„å•è¯åˆ—è¡¨
                    const savedShownWords = localStorage.getItem('vocabularyShownWords');
                    if (savedShownWords) {
                        shownWords = JSON.parse(savedShownWords);
                    }
                    
                    // è·å–å½“å‰æ˜¾ç¤ºçš„å•è¯
                    const savedCurrentWords = localStorage.getItem('vocabularyCurrentWords');
                    if (savedCurrentWords) {
                        return JSON.parse(savedCurrentWords);
                    }
                } catch (error) {
                    console.error('ä»æœ¬åœ°å­˜å‚¨åŠ è½½å¤±è´¥:', error);
                }
                return null;
            }
            
            // ä¿å­˜æ•°æ®åˆ°localStorage
            function saveToLocalStorage() {
                try {
                    localStorage.setItem('vocabularyShownWords', JSON.stringify(shownWords));
                    localStorage.setItem('vocabularyCurrentWords', JSON.stringify(currentDisplayedWords));
                } catch (error) {
                    console.error('ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨å¤±è´¥:', error);
                }
            }
            
            // æ˜¾ç¤ºå•è¯åˆ—è¡¨
            function displayWords(words, saveToStorage = true) {
                const wordList = document.getElementById('wordList');
                if (!wordList) {
                    console.error('æ‰¾ä¸åˆ°wordListå…ƒç´ ');
                    return;
                }
                
                wordList.innerHTML = '';
                words.forEach(word => {
                    const wordCard = createWordCard(word);
                    wordList.appendChild(wordCard);
                });
                
                // ä»…å½“éœ€è¦ä¿å­˜æ—¶æ›´æ–°å½“å‰æ˜¾ç¤ºçš„å•è¯
                if (saveToStorage) {
                    currentDisplayedWords = words;
                    saveToLocalStorage();
                }
            }
            
            // æ˜¾ç¤ºéšæœº50ä¸ªå•è¯ï¼Œä¸é‡å¤ç›´åˆ°å…¨éƒ¨å±•ç¤ºè¿‡
            function showRandomWords(forceUpdate = false) {
                // åªæœ‰å½“å¼ºåˆ¶æ›´æ–°æ—¶æ‰é‡æ–°é€‰æ‹©å•è¯
                if (!forceUpdate) {
                    // å¦‚æœä¸æ˜¯å¼ºåˆ¶æ›´æ–°ï¼Œå¹¶ä¸”å·²ç»æœ‰å•è¯æ˜¾ç¤ºï¼Œåˆ™ä¿æŒä¸å˜
                    if (currentDisplayedWords.length > 0) {
                        displayWords(currentDisplayedWords);
                        return;
                    }
                }
                
                // å¦‚æœæ²¡æœ‰å•è¯æ•°æ®ï¼Œåˆ™è¿”å›
                if (!allWords || allWords.length === 0) {
                    console.error('å°è¯•æ˜¾ç¤ºéšæœºå•è¯ï¼Œä½†allWordsä¸ºç©º');
                    return;
                }
                
                // å¦‚æœshownWordså·²ç»åŒ…å«äº†æ‰€æœ‰å•è¯ï¼Œåˆ™é‡ç½®
                if (shownWords.length >= allWords.length) {
                    shownWords = [];
                }
                
                // è¿‡æ»¤å‡ºæœªå±•ç¤ºè¿‡çš„å•è¯
                const notShownWords = allWords.filter(word => 
                    !shownWords.includes(word.word)
                );
                
                // éšæœºé€‰æ‹©å•è¯
                let selectedWords = [];
                
                // å¦‚æœæœªå±•ç¤ºçš„å•è¯è¶…è¿‡50ä¸ªï¼Œä»ä¸­éšæœºé€‰æ‹©50ä¸ª
                if (notShownWords.length >= 50) {
                    const shuffled = [...notShownWords].sort(() => 0.5 - Math.random());
                    selectedWords = shuffled.slice(0, 50);
                } 
                // å¦‚æœæœªå±•ç¤ºçš„å•è¯ä¸è¶³50ä¸ªï¼Œä½¿ç”¨æ‰€æœ‰æœªå±•ç¤ºçš„å•è¯ï¼Œå¹¶ä»ä¹‹å‰å·²å±•ç¤ºçš„å•è¯ä¸­è¡¥å……
                else {
                    selectedWords = [...notShownWords];
                    
                    // éœ€è¦è¡¥å……çš„å•è¯æ•°é‡
                    const needMore = 50 - notShownWords.length;
                    
                    if (needMore > 0 && allWords.length >= 50) {
                        // ä»å·²å±•ç¤ºè¿‡çš„å•è¯ä¸­éšæœºé€‰æ‹©è¡¥å……
                        const previouslyShown = allWords.filter(word => 
                            shownWords.includes(word.word)
                        );
                        
                        const shuffledPrevious = [...previouslyShown].sort(() => 0.5 - Math.random());
                        selectedWords = [...selectedWords, ...shuffledPrevious.slice(0, needMore)];
                    }
                }
                
                // æ›´æ–°å·²å±•ç¤ºå•è¯è®°å½• - ä½¿ç”¨å•è¯çš„åŸå§‹å¤§å°å†™å½¢å¼
                notShownWords.forEach(word => {
                    if (!shownWords.includes(word.word)) {
                        shownWords.push(word.word);
                    }
                });
                
                // æ˜¾ç¤ºé€‰ä¸­çš„å•è¯å¹¶ä¿å­˜
                displayWords(selectedWords, true);
            }
            
            // æœç´¢åŠŸèƒ½
            const searchBtn = document.getElementById('searchBtn');
            const randomBtn = document.getElementById('randomBtn');
            const wordList = document.getElementById('wordList');
            const searchInput = document.getElementById('searchInput');
            
            // æœç´¢æŒ‰é’®ç‚¹å‡»äº‹ä»¶
            if (searchBtn) {
                searchBtn.addEventListener('click', performSearch);
            }

            // æœç´¢è¾“å…¥æ¡†å›è½¦äº‹ä»¶
            if (searchInput) {
                searchInput.addEventListener('keypress', function(event) {
                    if (event.key === 'Enter') {
                        event.preventDefault();
                        performSearch();
                    }
                });
            }

            // éšæœºæŒ‰é’®ç‚¹å‡»äº‹ä»¶
            if (randomBtn) {
                randomBtn.addEventListener('click', function() {
                    showRandomWords(true);
                });
            }
            
            // æ‰§è¡Œæœç´¢çš„å‡½æ•°
            function performSearch() {
                const searchTerm = searchInput.value.trim();
                const caseSensitive = document.getElementById('caseSensitiveCheckbox').checked;
                
                if (searchTerm !== '') {
                    // æ ¹æ®å¤é€‰æ¡†çŠ¶æ€å†³å®šæ˜¯å¦åŒºåˆ†å¤§å°å†™
                    fetch(`/search_words?term=${encodeURIComponent(searchTerm)}&case_sensitive=${caseSensitive}`)
                        .then(response => response.json())
                        .then(data => {
                            if (data.words && data.words.length > 0) {
                                // æœç´¢ç»“æœä¸ä¿å­˜åˆ°currentDisplayedWordsä¸­
                                displayWords(data.words, false);
                            } else {
                                // å¦‚æœæ²¡æœ‰æ‰¾åˆ°å•è¯ï¼Œæ˜¾ç¤ºæ·»åŠ å•è¯çš„å¼¹çª—
                                showAddWordModal(searchTerm);
                            }
                        })
                        .catch(error => {
                            console.error('æœç´¢è¯·æ±‚å¤±è´¥:', error);
                            showNotification('æœç´¢è¯·æ±‚å¤±è´¥ï¼Œè¯·é‡è¯•', 'error');
                        });
                } else {
                    // å¦‚æœæœç´¢æ¡†ä¸ºç©ºï¼Œæ¢å¤æ˜¾ç¤ºå½“å‰çš„å›ºå®šå•è¯
                    displayWords(currentDisplayedWords);
                }
            }
            
            // è·å–å•è¯æ•°æ® - æ”¾åœ¨DOMContentLoadedäº‹ä»¶å†…çš„æœ€åï¼Œç¡®ä¿å‰é¢çš„å‡½æ•°éƒ½å·²å®šä¹‰
            fetch('/get_words')
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    if (!data.words) {
                        console.error('APIè¿”å›çš„æ•°æ®ä¸­æ²¡æœ‰wordså­—æ®µ:', data);
                        return;
                    }
                    
                    allWords = data.words;
                    console.log(`æˆåŠŸåŠ è½½äº† ${allWords.length} ä¸ªå•è¯`);
                    
                    // å°è¯•ä»æœ¬åœ°å­˜å‚¨ä¸­æ¢å¤å½“å‰æ˜¾ç¤ºçš„å•è¯
                    const savedWords = loadFromLocalStorage();
                    
                    if (savedWords && savedWords.length > 0) {
                        // éªŒè¯ä¿å­˜çš„å•è¯åœ¨å½“å‰è¯åº“ä¸­å­˜åœ¨
                        const wordMap = {};
                        allWords.forEach(word => {
                            wordMap[word.word] = word;
                        });
                        
                        // è¿‡æ»¤å‡ºæœ‰æ•ˆçš„å•è¯
                        const validSavedWords = savedWords.filter(word => wordMap[word.word]);
                        
                        if (validSavedWords.length > 0) {
                            // å¦‚æœæœ‰æœ‰æ•ˆçš„ä¿å­˜å•è¯ï¼Œä½¿ç”¨å®ƒä»¬
                            currentDisplayedWords = validSavedWords;
                            displayWords(currentDisplayedWords);
                            console.log('ä»æœ¬åœ°å­˜å‚¨æ¢å¤äº†', validSavedWords.length, 'ä¸ªå•è¯');
                            return;
                        }
                    }
                    
                    // å¦‚æœæ²¡æœ‰æœ‰æ•ˆçš„ä¿å­˜æ•°æ®ï¼Œéšæœºé€‰æ‹©æ–°å•è¯
                    showRandomWords(true);
                })
                .catch(error => {
                    console.error('è·å–å•è¯æ•°æ®å¤±è´¥:', error);
                });

            // åˆ›å»ºå•è¯å¡ç‰‡
            function createWordCard(word) {
                // å¤„ç†å¤šä¸ªè¯æ€§å’Œå«ä¹‰
                const processTranslation = (translation) => {
                    // æ£€æŸ¥æ˜¯å¦æœ‰å¤šä¸ªè¯æ€§å’Œå«ä¹‰
                    const partsOfSpeech = [];
                    const meanings = [];
                    
                    // æ‹†åˆ†å•è¯çš„ç¿»è¯‘å†…å®¹ï¼Œæ”¯æŒå¤šä¸ªè¯æ€§
                    // ä¾‹å¦‚ï¼š"vt.ä¸¢å¼ƒï¼›æ”¾å¼ƒï¼ŒæŠ›å¼ƒ" æˆ– "n.æ‘˜è¦ a.æŠ½è±¡çš„"
                    
                    // ä¼˜åŒ–å¤„ç†è¿ç»­è¯æ€§çš„æƒ…å†µï¼Œå¦‚ "vi.äº¤è°ˆ vt.è°ˆè®º"
                    translation = translation.replace(/([a-z]+\.)\s+([a-z]+\.)/g, '$1|$2');
                    
                    // é¦–å…ˆå°è¯•æŒ‰ç©ºæ ¼å’Œè¯æ€§åˆ†éš”ç¬¦åˆ‡åˆ†
                    const posPattern = /([a-z]+\.)/g; // åŒ¹é…è¯æ€§å¦‚ n. vt. adj. ç­‰
                    let matches = translation.match(posPattern);
                    
                    if (matches && matches.length > 0) {
                        // æœ‰è¯æ€§æ ‡è®°ï¼ŒæŒ‰è¯æ€§åˆ†æ®µ
                        // ä½¿ç”¨æ›´å¤æ‚çš„åˆ†å‰²æ–¹æ³•ï¼Œå¤„ç†å¤šä¸ªè¯æ€§
                        let segments = [];
                        let lastIndex = 0;
                        let match;
                        
                        // é‡ç½®æ­£åˆ™è¡¨è¾¾å¼
                        posPattern.lastIndex = 0;
                        
                        // é€ä¸ªæ‰¾å‡ºæ‰€æœ‰è¯æ€§æ ‡è®°çš„ä½ç½®
                        while ((match = posPattern.exec(translation)) !== null) {
                            if (match.index > lastIndex) {
                                // å¦‚æœå½“å‰è¯æ€§æ ‡è®°å‰æœ‰å†…å®¹ï¼ˆä¸Šä¸€ä¸ªè¯æ€§çš„å«ä¹‰ï¼‰
                                segments.push(translation.substring(lastIndex, match.index).trim());
                            }
                            // æ·»åŠ è¯æ€§æ ‡è®°
                            segments.push(match[0]);
                            lastIndex = match.index + match[0].length;
                        }
                        
                        // æ·»åŠ æœ€åä¸€éƒ¨åˆ†
                        if (lastIndex < translation.length) {
                            segments.push(translation.substring(lastIndex).trim());
                        }
                        
                        // è¿‡æ»¤ç©ºå­—ç¬¦ä¸²
                        segments = segments.filter(s => s.trim());
                        
                        // æ¢å¤è¢«æ›¿æ¢çš„åˆ†éš”ç¬¦
                        segments = segments.map(s => s.replace(/\|/g, ' '));
                        
                        // é‡ç»„è¯æ€§å’Œå¯¹åº”çš„å«ä¹‰
                        for (let i = 0; i < segments.length; i++) {
                            if (segments[i].match(/^[a-z]+\.$/)) {
                                // è¿™æ˜¯è¯æ€§
                                const pos = segments[i];
                                // ä¸‹ä¸€ä¸ªå…ƒç´ åº”è¯¥æ˜¯å«ä¹‰
                                if (i + 1 < segments.length && !segments[i + 1].match(/^[a-z]+\.$/)) {
                                    // æœ‰å¯¹åº”çš„å«ä¹‰
                                    let meaning = segments[i + 1];
                                    
                                    // å¤„ç†å«ä¹‰ä¸­çš„åˆ†å·åˆ†éš”çš„å¤šä¸ªè§£é‡Š
                                    if (meaning.includes('ï¼›')) {
                                        // å°†åˆ†å·æ›¿æ¢ä¸ºé€—å·ï¼Œä¿æŒåŒä¸€è¯æ€§çš„å«ä¹‰åœ¨åŒä¸€è¡Œ
                                        meaning = meaning.replace(/ï¼›/g, 'ï¼Œ');
                                        partsOfSpeech.push(pos);
                                        meanings.push(meaning.trim());
                                    } else {
                                        partsOfSpeech.push(pos);
                                        meanings.push(meaning.trim());
                                    }
                                    
                                    i++; // è·³è¿‡å·²å¤„ç†çš„å«ä¹‰
                                } else {
                                    // æ²¡æœ‰å¯¹åº”çš„å«ä¹‰ï¼Œå¯èƒ½æ˜¯æ ¼å¼é—®é¢˜
                                    partsOfSpeech.push(pos);
                                    meanings.push('');
                                }
                            } else if (!segments[i].match(/^[a-z]+\.$/)) {
                                // è¿™æ˜¯æ²¡æœ‰è¯æ€§æ ‡è®°çš„å«ä¹‰ï¼Œå¯èƒ½æ˜¯ç¿»è¯‘æ ¼å¼ä¸è§„èŒƒ
                                partsOfSpeech.push('');
                                meanings.push(segments[i].trim());
                            }
                        }
                    } else {
                        // æ²¡æœ‰æ‰¾åˆ°è¯æ€§æ ‡è®°ï¼Œå°è¯•å…¶ä»–æ–¹å¼åˆ†å‰²
                        // æ£€æŸ¥æ˜¯å¦åŒ…å«åˆ†å·ï¼Œè¡¨ç¤ºå¤šä¸ªå«ä¹‰
                        if (translation.includes('ï¼›')) {
                            const parts = translation.split('ï¼›');
                            // æ£€æŸ¥ç¬¬ä¸€éƒ¨åˆ†æ˜¯å¦åŒ…å«è¯æ€§
                            const firstPart = parts[0];
                            const dotIndex = firstPart.indexOf('.');
                            
                            if (dotIndex > 0 && dotIndex < 5) {
                                // æœ‰è¯æ€§æ ‡è®°
                                const pos = firstPart.substring(0, dotIndex + 1);
                                const firstMeaning = firstPart.substring(dotIndex + 1).trim();
                                
                                // å°†æ‰€æœ‰å«ä¹‰åˆå¹¶ä¸ºä¸€ä¸ªï¼Œç”¨é€—å·åˆ†éš”
                                let allMeanings = firstMeaning;
                                for (let i = 1; i < parts.length; i++) {
                                    allMeanings += 'ï¼Œ' + parts[i].trim();
                                }
                                
                                partsOfSpeech.push(pos);
                                meanings.push(allMeanings);
                            } else {
                                // æ²¡æœ‰è¯æ€§æ ‡è®°ï¼Œå…¨éƒ¨ä½œä¸ºå«ä¹‰
                                partsOfSpeech.push('');
                                meanings.push(translation);
                            }
                        } else {
                            // æ²¡æœ‰åˆ†å·ï¼Œæ£€æŸ¥æ˜¯å¦æœ‰è¯æ€§æ ‡è®°
                            const dotIndex = translation.indexOf('.');
                            if (dotIndex > 0 && dotIndex < 5) {
                                // æœ‰è¯æ€§æ ‡è®°
                                partsOfSpeech.push(translation.substring(0, dotIndex + 1));
                                meanings.push(translation.substring(dotIndex + 1).trim());
                            } else {
                                // æ²¡æœ‰è¯æ€§æ ‡è®°ï¼Œå…¨éƒ¨ä½œä¸ºå«ä¹‰
                                partsOfSpeech.push('');
                                meanings.push(translation);
                            }
                        }
                    }
                    
                    // å¦‚æœæ²¡æœ‰è¯†åˆ«å‡ºä»»ä½•è¯æ€§å’Œå«ä¹‰ï¼Œè¿”å›åŸå§‹ç¿»è¯‘
                    if (partsOfSpeech.length === 0) {
                        return [{
                            partOfSpeech: '',
                            meaning: translation
                        }];
                    }
                    
                    // åˆå¹¶ç›¸åŒè¯æ€§çš„å«ä¹‰
                    const result = [];
                    let currentPos = '';
                    let currentMeanings = [];
                    
                    for (let i = 0; i < partsOfSpeech.length; i++) {
                        if (partsOfSpeech[i] && partsOfSpeech[i] !== currentPos) {
                            // æ–°çš„è¯æ€§å¼€å§‹ï¼Œå…ˆä¿å­˜ä¹‹å‰çš„ç»“æœ
                            if (currentPos && currentMeanings.length > 0) {
                                result.push({
                                    partOfSpeech: currentPos,
                                    meaning: currentMeanings.join('ï¼Œ')
                                });
                                currentMeanings = [];
                            }
                            
                            // æ›´æ–°å½“å‰è¯æ€§
                            currentPos = partsOfSpeech[i];
                            currentMeanings.push(meanings[i]);
                        } else if (partsOfSpeech[i] === currentPos) {
                            // ç›¸åŒè¯æ€§ï¼Œæ·»åŠ åˆ°å½“å‰å«ä¹‰åˆ—è¡¨
                            currentMeanings.push(meanings[i]);
                        } else if (!partsOfSpeech[i] && currentPos) {
                            // æ²¡æœ‰è¯æ€§ä½†å±äºå‰ä¸€ä¸ªè¯æ€§
                            currentMeanings.push(meanings[i]);
                        } else {
                            // å®Œå…¨æ²¡æœ‰è¯æ€§çš„æƒ…å†µ
                            if (currentPos && currentMeanings.length > 0) {
                                // ä¿å­˜ä¹‹å‰çš„ç»“æœ
                                result.push({
                                    partOfSpeech: currentPos,
                                    meaning: currentMeanings.join('ï¼Œ')
                                });
                                currentMeanings = [];
                                currentPos = '';
                            }
                            
                            // æ·»åŠ æ— è¯æ€§çš„å«ä¹‰
                            result.push({
                                partOfSpeech: '',
                                meaning: meanings[i]
                            });
                        }
                    }
                    
                    // æ·»åŠ æœ€åä¸€ç»„
                    if (currentPos && currentMeanings.length > 0) {
                        result.push({
                            partOfSpeech: currentPos,
                            meaning: currentMeanings.join('ï¼Œ')
                        });
                    }
                    
                    return result;
                };
                
                // å¤„ç†å•è¯çš„ç¿»è¯‘
                const parsedTranslations = processTranslation(word.translation);
                
                // åˆ›å»ºå¡ç‰‡
                const card = document.createElement('div');
                card.className = 'word-card';
                
                // åˆ›å»ºæœ—è¯»æŒ‰é’®çš„å‡½æ•°
                const createPronunciationBtn = () => {
                    const btn = document.createElement('button');
                    btn.className = 'pronunciation-btn';
                    btn.title = 'æœ—è¯»';
                    btn.innerHTML = `
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
                            <path d="M15.54 8.46a5 5 0 0 1 0 7.07"></path>
                            <path d="M19.07 4.93a10 10 0 0 1 0 14.14"></path>
                        </svg>
                    `;
                    
                    // ä½¿ç”¨äº‹ä»¶ç›‘å¬å™¨è€Œä¸æ˜¯å†…è”onclickï¼Œé¿å…å¼•å·è½¬ä¹‰é—®é¢˜
                    btn.addEventListener('click', (event) => {
                        event.stopPropagation(); // é˜»æ­¢äº‹ä»¶å†’æ³¡
                        speakWord(word.word);
                    });
                    
                    return btn;
                };
                
                // åˆ›å»ºå¡ç‰‡å†…å®¹
                const frontSide = document.createElement('div');
                frontSide.className = 'word-front';
                
                const wordText = document.createElement('h3');
                wordText.className = 'word-text';
                wordText.textContent = word.word;
                
                const wordDetails = document.createElement('div');
                wordDetails.className = 'word-details';
                
                // æ·»åŠ æ¯ä¸ªè¯æ€§å’Œå«ä¹‰
                parsedTranslations.forEach((item, index) => {
                    const entryContainer = document.createElement('div');
                    entryContainer.className = 'translation-entry';
                    
                    // å¦‚æœæœ‰è¯æ€§ï¼Œæ˜¾ç¤ºè¯æ€§
                    if (item.partOfSpeech) {
                        const posSpan = document.createElement('span');
                        posSpan.className = 'part-of-speech';
                        posSpan.textContent = item.partOfSpeech;
                        entryContainer.appendChild(posSpan);
                    }
                    
                    const meaningP = document.createElement('p');
                    meaningP.className = 'word-meaning';
                    meaningP.textContent = item.meaning;
                    entryContainer.appendChild(meaningP);
                    
                    wordDetails.appendChild(entryContainer);
                });
                
                // å¦‚æœæœ‰levelå±æ€§ï¼Œæ·»åŠ æ˜¾ç¤º
                if (word.level) {
                    const levelSpan = document.createElement('span');
                    levelSpan.className = 'word-level';
                    levelSpan.textContent = word.level;
                    wordDetails.appendChild(levelSpan);
                }
                
                // ç»„è£…å‰é¢
                frontSide.appendChild(wordText);
                frontSide.appendChild(createPronunciationBtn());
                frontSide.appendChild(wordDetails);
                
                // åˆ›å»ºèƒŒé¢
                const backSide = document.createElement('div');
                backSide.className = 'word-back';
                
                const wordDetailsBack = document.createElement('div');
                wordDetailsBack.className = 'word-details-back';
                
                const wordTextBack = document.createElement('h3');
                wordTextBack.className = 'word-text';
                wordTextBack.textContent = word.word;
                
                // æ·»åŠ æ¯ä¸ªè¯æ€§å’Œå«ä¹‰åˆ°èƒŒé¢
                parsedTranslations.forEach((item, index) => {
                    const entryContainer = document.createElement('div');
                    entryContainer.className = 'translation-entry';
                    
                    // å¦‚æœæœ‰è¯æ€§ï¼Œæ˜¾ç¤ºè¯æ€§
                    if (item.partOfSpeech) {
                        const posSpanBack = document.createElement('span');
                        posSpanBack.className = 'part-of-speech';
                        posSpanBack.textContent = item.partOfSpeech;
                        entryContainer.appendChild(posSpanBack);
                    }
                    
                    const meaningPBack = document.createElement('p');
                    meaningPBack.className = 'word-meaning';
                    meaningPBack.textContent = item.meaning;
                    entryContainer.appendChild(meaningPBack);
                    
                    wordDetailsBack.appendChild(entryContainer);
                });
                
                // å¦‚æœæœ‰levelå±æ€§ï¼Œæ·»åŠ æ˜¾ç¤ºåˆ°èƒŒé¢
                if (word.level) {
                    const levelSpanBack = document.createElement('span');
                    levelSpanBack.className = 'word-level';
                    levelSpanBack.textContent = word.level;
                    wordDetailsBack.appendChild(levelSpanBack);
                }
                
                // ç»„è£…èƒŒé¢
                wordDetailsBack.insertBefore(wordTextBack, wordDetailsBack.firstChild);
                wordDetailsBack.insertBefore(createPronunciationBtn(), wordDetailsBack.firstChild.nextSibling);
                backSide.appendChild(wordDetailsBack);
                
                // ç»„è£…å¡ç‰‡
                card.appendChild(frontSide);
                card.appendChild(backSide);
                
                // ç‚¹å‡»å¡ç‰‡ç¿»è½¬
                card.addEventListener('click', function() {
                    this.classList.toggle('flipped');
                });
                
                return card;
            }

            // æœ—è¯»å•è¯çš„å‡½æ•°
            function speakWord(word) {
                // è·å–æ‰€æœ‰ä¸è¿™ä¸ªå•è¯ç›¸å…³çš„å‘éŸ³æŒ‰é’®
                const speakerButtons = document.querySelectorAll(`.pronunciation-btn[onclick*="${word}"]`);
                
                // å½“å¼€å§‹æœ—è¯»æ—¶æ”¹å˜æŒ‰é’®å¤–è§‚
                speakerButtons.forEach(btn => {
                    btn.classList.add('speaking');
                });
                
                // å°è¯•ä½¿ç”¨æµè§ˆå™¨å†…ç½®è¯­éŸ³æœ—è¯»
                if ('speechSynthesis' in window) {
                    try {
                        // å…ˆåœæ­¢ä¹‹å‰å¯èƒ½æ­£åœ¨è¿›è¡Œçš„æœ—è¯»
                        window.speechSynthesis.cancel();
                        
                        // åˆ›å»ºè¯­éŸ³åˆæˆå®ä¾‹
                        const utterance = new SpeechSynthesisUtterance(word);
                        utterance.lang = 'en-US'; // è®¾ç½®è¯­è¨€ä¸ºè‹±è¯­
                        utterance.voice = findEnglishVoice(); // å°è¯•æ‰¾åˆ°è‹±è¯­è¯­éŸ³
                        utterance.rate = 0.9; // è¯­é€Ÿç¨å¾®æ…¢ä¸€ç‚¹
                        utterance.volume = 1.0; // ç¡®ä¿éŸ³é‡è¶³å¤Ÿ
                        
                        // å½“æœ—è¯»ç»“æŸæ—¶æ¢å¤æŒ‰é’®å¤–è§‚
                        utterance.onend = function() {
                            speakerButtons.forEach(btn => {
                                btn.classList.remove('speaking');
                            });
                        };
                        
                        // å¤„ç†æœ—è¯»é”™è¯¯
                        utterance.onerror = function(event) {
                            console.error('æµè§ˆå™¨æœ—è¯»é”™è¯¯:', event);
                            // å¦‚æœæµè§ˆå™¨æœ—è¯»å¤±è´¥ï¼Œå°è¯•ä½¿ç”¨APIæœ—è¯»
                            useFallbackAudio(word, speakerButtons);
                        };
                        
                        // å¼€å§‹æœ—è¯»
                        window.speechSynthesis.speak(utterance);
                        console.log(`æ­£åœ¨ä½¿ç”¨æµè§ˆå™¨æœ—è¯»: "${word}"`);
                    } catch (error) {
                        console.error('æœ—è¯»å‡ºé”™:', error);
                        // å¦‚æœå‡ºé”™ï¼Œä½¿ç”¨å¤‡é€‰æœ—è¯»æ–¹å¼
                        useFallbackAudio(word, speakerButtons);
                    }
                } else {
                    // å¦‚æœæµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³åˆæˆï¼Œä½¿ç”¨å¤‡é€‰æœ—è¯»æ–¹å¼
                    console.log('æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³åˆæˆï¼Œä½¿ç”¨å¤‡é€‰æ–¹æ¡ˆ');
                    useFallbackAudio(word, speakerButtons);
                }
            }
            
            // ä½¿ç”¨æœåŠ¡å™¨APIæœ—è¯»å•è¯
            function useFallbackAudio(word, speakerButtons) {
                try {
                    // åˆ›å»ºéŸ³é¢‘å…ƒç´ 
                    const audio = new Audio();
                    
                    // ä½¿ç”¨ç›´æ¥è¿”å›éŸ³é¢‘çš„APIç«¯ç‚¹
                    audio.src = `/get_pronunciation?word=${encodeURIComponent(word)}&t=${new Date().getTime()}`;
                    
                    // è®¾ç½®éŸ³é¢‘äº‹ä»¶å¤„ç†
                    audio.onended = function() {
                        speakerButtons.forEach(btn => {
                            btn.classList.remove('speaking');
                        });
                        console.log('éŸ³é¢‘æ’­æ”¾å®Œæˆ');
                    };
                    
                    audio.onerror = function(e) {
                        console.error('éŸ³é¢‘æ’­æ”¾é”™è¯¯:', e);
                        speakerButtons.forEach(btn => {
                            btn.classList.remove('speaking');
                        });
                        
                        // ä½¿ç”¨è‡ªå®šä¹‰é€šçŸ¥æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯
                        showNotification('æ— æ³•æ’­æ”¾å‘éŸ³', 'error', 3000);
                    };
                    
                    // å°è¯•æ’­æ”¾éŸ³é¢‘
                    const playPromise = audio.play();
                    
                    if (playPromise !== undefined) {
                        playPromise.catch(error => {
                            console.error('éŸ³é¢‘æ’­æ”¾Promiseé”™è¯¯:', error);
                            speakerButtons.forEach(btn => {
                                btn.classList.remove('speaking');
                            });
                        });
                    }
                    
                    console.log(`æ­£åœ¨ä½¿ç”¨APIæœ—è¯»: "${word}"`);
                } catch (error) {
                    console.error('éŸ³é¢‘åˆ›å»ºæˆ–æ’­æ”¾å¤±è´¥:', error);
                    speakerButtons.forEach(btn => {
                        btn.classList.remove('speaking');
                    });
                }
            }
            
            // å°è¯•æŸ¥æ‰¾è‹±è¯­è¯­éŸ³
            function findEnglishVoice() {
                if (!window.speechSynthesis) return null;
                
                // ç­‰å¾…è¯­éŸ³åˆ—è¡¨åŠ è½½
                let voices = window.speechSynthesis.getVoices();
                if (voices.length === 0) {
                    // åœ¨æŸäº›æµè§ˆå™¨ä¸­ï¼Œvoices å¯èƒ½éœ€è¦ä¸€æ®µæ—¶é—´æ‰èƒ½åŠ è½½
                    return null; // å°†ä½¿ç”¨é»˜è®¤è¯­éŸ³
                }
                
                // ä¼˜å…ˆæŸ¥æ‰¾è‹±è¯­ï¼ˆç¾å›½ï¼‰è¯­éŸ³
                let voice = voices.find(voice => /en-US/i.test(voice.lang) && voice.localService);
                
                // å¦‚æœæ²¡æœ‰æ‰¾åˆ°è‹±è¯­ï¼ˆç¾å›½ï¼‰è¯­éŸ³ï¼Œå°è¯•æŸ¥æ‰¾ä»»ä½•è‹±è¯­è¯­éŸ³
                if (!voice) {
                    voice = voices.find(voice => /en/i.test(voice.lang));
                }
                
                // å¦‚æœä»ç„¶æ²¡æœ‰æ‰¾åˆ°ï¼Œä½¿ç”¨é»˜è®¤è¯­éŸ³
                return voice || null;
            }
            
            // ç¡®ä¿è¯­éŸ³åˆ—è¡¨åŠ è½½
            if ('speechSynthesis' in window) {
                // Chrome éœ€è¦è§¦å‘è¿™ä¸ªäº‹ä»¶æ¥åŠ è½½è¯­éŸ³
                speechSynthesis.onvoiceschanged = function() {
                    findEnglishVoice();
                };
                // é¢„åŠ è½½è¯­éŸ³
                speechSynthesis.getVoices();
            }

            // æ˜¾ç¤ºæ·»åŠ å•è¯çš„å¼¹çª—
            function showAddWordModal(word) {
                const modal = document.getElementById('addWordModal');
                const searchedWordSpan = document.getElementById('searchedWord');
                const wordInput = document.getElementById('wordInput');
                const translationInput = document.getElementById('translationInput');
                
                // è®¾ç½®å¼¹çª—ä¸­çš„å•è¯ - ä¿ç•™åŸå§‹è¾“å…¥çš„å¤§å°å†™
                searchedWordSpan.textContent = word;
                wordInput.value = word;
                translationInput.value = '';
                
                // æ˜¾ç¤ºå¼¹çª—
                modal.style.display = 'flex';
            }
            
            // å…³é—­å¼¹çª—
            document.querySelector('.close-modal').addEventListener('click', function() {
                document.getElementById('addWordModal').style.display = 'none';
            });
            
            // ç‚¹å‡»å–æ¶ˆæŒ‰é’®å…³é—­å¼¹çª—
            document.getElementById('cancelAddBtn').addEventListener('click', function() {
                document.getElementById('addWordModal').style.display = 'none';
            });
            
            // ç‚¹å‡»æ¨¡æ€æ¡†å¤–éƒ¨å…³é—­æ¨¡æ€æ¡†
            window.addEventListener('click', function(event) {
                const modal = document.getElementById('addWordModal');
                if (event.target === modal) {
                    modal.style.display = 'none';
                }
            });
            
            // æ·»åŠ å•è¯æŒ‰é’®ç‚¹å‡»äº‹ä»¶
            document.getElementById('addWordBtn').addEventListener('click', function() {
                const wordInput = document.getElementById('wordInput');
                const translationInput = document.getElementById('translationInput');
                
                const word = wordInput.value.trim();
                const translation = translationInput.value.trim();
                
                if (!word) {
                    showNotification('è¯·è¾“å…¥å•è¯', 'warning');
                    return;
                }
                
                if (!translation) {
                    showNotification('è¯·è¾“å…¥ç¿»è¯‘', 'warning');
                    return;
                }
                
                // å‘é€æ·»åŠ å•è¯çš„è¯·æ±‚
                fetch('/add_word', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        word: word,
                        translation: translation
                    })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        // å…³é—­å¼¹çª—
                        document.getElementById('addWordModal').style.display = 'none';
                        
                        // æ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯
                        showNotification('å•è¯å·²æˆåŠŸæ·»åŠ åˆ°å•è¯åº“!', 'success');
                        
                        // å°†æ–°å•è¯æ·»åŠ åˆ°allWords
                        const newWord = data.word;
                        allWords.push(newWord);
                        
                        // æ˜¾ç¤ºåŒ…å«è¿™ä¸ªæ–°å•è¯çš„å•è¯å¡ç‰‡
                        displayWords([newWord], false);
                        
                        // æ¸…ç©ºæœç´¢æ¡†
                        searchInput.value = '';
                    } else {
                        showNotification('æ·»åŠ å•è¯å¤±è´¥: ' + data.error, 'error');
                    }
                })
                .catch(error => {
                    console.error('æ·»åŠ å•è¯è¯·æ±‚å¤±è´¥:', error);
                    showNotification('æ·»åŠ å•è¯è¯·æ±‚å¤±è´¥ï¼Œè¯·é‡è¯•', 'error');
                });
            });

            // æ˜¾ç¤ºé€šçŸ¥æç¤ºæ¡†
            function showNotification(message, type = 'info', duration = 3000) {
                // åˆ›å»ºé€šçŸ¥å…ƒç´ 
                const notification = document.createElement('div');
                notification.className = `notification notification-${type}`;
                
                // æ·»åŠ é€šçŸ¥å†…å®¹
                const content = document.createElement('div');
                content.className = 'notification-content';
                content.textContent = message;
                
                // æ·»åŠ å…³é—­æŒ‰é’®
                const closeBtn = document.createElement('span');
                closeBtn.className = 'notification-close';
                closeBtn.innerHTML = '&times;';
                closeBtn.addEventListener('click', () => {
                    notification.classList.add('fade-out');
                    setTimeout(() => {
                        if (document.body.contains(notification)) {
                            document.body.removeChild(notification);
                        }
                    }, 300);
                });
                
                // ç»„è£…é€šçŸ¥
                notification.appendChild(content);
                notification.appendChild(closeBtn);
                document.body.appendChild(notification);
                
                // è®¾ç½®è‡ªåŠ¨å…³é—­
                if (duration > 0) {
                    setTimeout(() => {
                        if (document.body.contains(notification)) {
                            notification.classList.add('fade-out');
                            setTimeout(() => {
                                if (document.body.contains(notification)) {
                                    document.body.removeChild(notification);
                                }
                            }, 300);
                        }
                    }, duration);
                }
                
                return notification;
            }
        });
    </script>
</body>
</html> 